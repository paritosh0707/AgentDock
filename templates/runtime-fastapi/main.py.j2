"""
Dockrion Generated Runtime
==========================
Agent: {{ agent.name }}
Framework: {{ agent.framework }}
Description: {{ agent.description | default('Dockrion Agent', true) }}

Auto-generated by Dockrion SDK v{{ dockrion_version | default('1.0.0') }}
Do not edit manually - regenerate using `dockrion build`
"""
import os
import sys
import time
import json
import asyncio
from pathlib import Path
from typing import Dict, Any, Optional, AsyncGenerator
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.responses import JSONResponse, Response, StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from prometheus_client import (
    generate_latest, 
    CONTENT_TYPE_LATEST,
    Counter,
    Histogram,
    Gauge
)

# Add project root to Python path for agent module imports
project_root = Path(__file__).parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

# Import Dockrion packages
from dockrion_adapters import get_adapter
from dockrion_schema import DockSpec
from dockrion_common.errors import DockrionError, ValidationError
from dockrion_common.logger import get_logger

# ============================================================================
# Configuration
# ============================================================================

AGENT_NAME = "{{ agent.name }}"
AGENT_FRAMEWORK = "{{ agent.framework }}"
AGENT_ENTRYPOINT = "{{ agent.entrypoint }}"
AGENT_DESCRIPTION = "{{ agent.description | default('Dockrion Agent', true) }}"

{%- if expose %}
HOST = "{{ expose.host | default('0.0.0.0') }}"
PORT = {{ expose.port | default(8080) }}
ENABLE_STREAMING = {{ 'True' if expose.streaming else 'False' }}
{%- else %}
HOST = "0.0.0.0"
PORT = 8080
ENABLE_STREAMING = False
{%- endif %}

{%- if auth %}
AUTH_ENABLED = {{ 'True' if auth.mode != 'none' else 'False' }}
AUTH_MODE = "{{ auth.mode | default('none') }}"
{%- else %}
AUTH_ENABLED = False
AUTH_MODE = "none"
{%- endif %}

{%- if model %}
MODEL_PROVIDER = "{{ model.provider | default('openai') }}"
MODEL_NAME = "{{ model.name | default('gpt-4o-mini') }}"
MODEL_TEMPERATURE = {{ model.temperature | default(0.7) }}
MODEL_MAX_TOKENS = {{ model.max_tokens | default(1500) }}
{%- endif %}

{%- if arguments %}
TIMEOUT_SEC = {{ arguments.timeout_sec | default(30) }}
{%- else %}
TIMEOUT_SEC = 30
{%- endif %}

# ============================================================================
# Logging & Metrics
# ============================================================================

logger = get_logger(__name__)

# Prometheus metrics
REQUEST_COUNT = Counter(
    'dockrion_requests_total',
    'Total number of requests',
    ['agent', 'endpoint', 'status']
)

REQUEST_LATENCY = Histogram(
    'dockrion_request_latency_seconds',
    'Request latency in seconds',
    ['agent', 'endpoint'],
    buckets=[0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0]
)

ACTIVE_REQUESTS = Gauge(
    'dockrion_active_requests',
    'Number of active requests',
    ['agent']
)

# ============================================================================
# Agent Specification (Embedded)
# ============================================================================

SPEC_DATA = {{ spec_json }}

# ============================================================================
# Application Lifecycle
# ============================================================================

adapter = None
spec = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifecycle manager - handles startup and shutdown."""
    global adapter, spec
    
    # Startup
    logger.info(f"ðŸš€ Starting Dockrion Agent: {AGENT_NAME}")
    logger.info(f"   Framework: {AGENT_FRAMEWORK}")
    logger.info(f"   Entrypoint: {AGENT_ENTRYPOINT}")
    
    try:
        # Load specification
        spec = DockSpec.model_validate(SPEC_DATA)
        logger.info("âœ… Specification loaded and validated")
        
        # Initialize adapter
        adapter = get_adapter(AGENT_FRAMEWORK)
        logger.info(f"âœ… {AGENT_FRAMEWORK} adapter initialized")
        
        # Load agent
        adapter.load(AGENT_ENTRYPOINT)
        logger.info(f"âœ… Agent loaded from {AGENT_ENTRYPOINT}")
        
        logger.info(f"ðŸŽ¯ Agent {AGENT_NAME} ready to serve requests on {HOST}:{PORT}")
        
    except Exception as e:
        logger.error(f"âŒ Failed to initialize agent: {e}")
        raise
    
    yield
    
    # Shutdown
    logger.info(f"ðŸ‘‹ Shutting down agent: {AGENT_NAME}")

# ============================================================================
# FastAPI Application
# ============================================================================

app = FastAPI(
    title=AGENT_NAME,
    description=AGENT_DESCRIPTION,
    version="{{ metadata.version | default('1.0.0') if metadata else '1.0.0' }}",
    lifespan=lifespan,
    docs_url="/docs",
    redoc_url="/redoc"
)

{%- if expose and expose.cors %}

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins={{ expose.cors.origins | default(['*']) | tojson }},
    allow_credentials=True,
    allow_methods={{ expose.cors.methods | default(['*']) | tojson }},
    allow_headers=["*"],
)
{%- endif %}

# ============================================================================
# Authentication
# ============================================================================

{%- if auth and auth.mode == 'api_key' %}

async def verify_api_key(request: Request) -> Optional[str]:
    """Verify API key from request headers."""
    api_key = request.headers.get("X-API-Key") or request.headers.get("Authorization", "").replace("Bearer ", "")
    
    if not api_key:
        raise HTTPException(
            status_code=401,
            detail="Missing API key. Provide via X-API-Key header or Authorization: Bearer <key>"
        )
    
    # Check against environment variable or configured keys
    valid_key = os.environ.get("DOCKRION_API_KEY", "")
    if api_key != valid_key:
        REQUEST_COUNT.labels(agent=AGENT_NAME, endpoint="auth", status="unauthorized").inc()
        raise HTTPException(status_code=401, detail="Invalid API key")
    
    return api_key

{%- else %}

async def verify_api_key(request: Request) -> Optional[str]:
    """No-op auth verification when auth is disabled."""
    return None

{%- endif %}

# ============================================================================
# Policy Engine
# ============================================================================

{%- if policies %}

class PolicyEngine:
    """Apply safety and governance policies to agent I/O."""
    
    def __init__(self, policies_config: Dict[str, Any]):
        self.config = policies_config
        {%- if policies.safety %}
        self.redact_patterns = {{ policies.safety.redact_patterns | default([]) | tojson }}
        self.max_output_chars = {{ policies.safety.max_output_chars | default(10000) }}
        self.block_prompt_injection = {{ 'True' if policies.safety.block_prompt_injection else 'False' }}
        {%- endif %}
        {%- if policies.tools %}
        self.allowed_tools = {{ policies.tools.allowed | default([]) | tojson }}
        self.deny_by_default = {{ 'True' if policies.tools.deny_by_default else 'False' }}
        {%- endif %}
    
    def validate_input(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Validate and sanitize input payload."""
        {%- if policies.safety and policies.safety.block_prompt_injection %}
        # Check for prompt injection patterns
        import re
        injection_patterns = [
            r"ignore\s+(previous|above|all)\s+instructions",
            r"system\s*:\s*",
            r"<\|.*\|>",
        ]
        payload_str = json.dumps(payload).lower()
        for pattern in injection_patterns:
            if re.search(pattern, payload_str, re.IGNORECASE):
                raise ValidationError("Potential prompt injection detected")
        {%- endif %}
        return payload
    
    def apply_output_policies(self, output: Dict[str, Any]) -> Dict[str, Any]:
        """Apply output policies (redaction, length limits)."""
        import re
        output_str = json.dumps(output)
        
        {%- if policies.safety and policies.safety.redact_patterns %}
        # Apply redaction patterns
        for pattern in self.redact_patterns:
            output_str = re.sub(pattern, "[REDACTED]", output_str)
        {%- endif %}
        
        {%- if policies.safety and policies.safety.max_output_chars %}
        # Enforce max output length
        if len(output_str) > self.max_output_chars:
            logger.warning(f"Output truncated from {len(output_str)} to {self.max_output_chars} chars")
            output_str = output_str[:self.max_output_chars]
        {%- endif %}
        
        return json.loads(output_str)

policy_engine = PolicyEngine({{ policies | tojson if policies else '{}' }})

{%- else %}

# No policies configured - passthrough
class PolicyEngine:
    def validate_input(self, payload): return payload
    def apply_output_policies(self, output): return output

policy_engine = PolicyEngine()

{%- endif %}

# ============================================================================
# Schema Validation
# ============================================================================

{%- if io_schema %}

def validate_input_schema(payload: Dict[str, Any]) -> None:
    """Validate input against defined schema."""
    {%- if io_schema.input and io_schema.input.required %}
    required_fields = {{ io_schema.input.required | tojson }}
    missing = [f for f in required_fields if f not in payload]
    if missing:
        raise ValidationError(f"Missing required fields: {missing}")
    {%- endif %}
    
    {%- if io_schema.input and io_schema.input.properties %}
    # Type validation for defined properties
    schema_props = {{ io_schema.input.properties | tojson }}
    for field, value in payload.items():
        if field in schema_props:
            expected_type = schema_props[field].get("type")
            if expected_type == "string" and not isinstance(value, str):
                raise ValidationError(f"Field '{field}' must be a string")
            elif expected_type == "number" and not isinstance(value, (int, float)):
                raise ValidationError(f"Field '{field}' must be a number")
            elif expected_type == "array" and not isinstance(value, list):
                raise ValidationError(f"Field '{field}' must be an array")
            elif expected_type == "object" and not isinstance(value, dict):
                raise ValidationError(f"Field '{field}' must be an object")
    {%- endif %}

{%- else %}

def validate_input_schema(payload: Dict[str, Any]) -> None:
    """No schema validation configured."""
    pass

{%- endif %}

# ============================================================================
# API Endpoints
# ============================================================================

@app.get("/health")
async def health_check():
    """Health check endpoint for load balancers and orchestrators."""
    return {
        "status": "healthy",
        "agent": AGENT_NAME,
        "framework": AGENT_FRAMEWORK,
        "version": "{{ metadata.version | default('1.0.0') if metadata else '1.0.0' }}"
    }


@app.get("/ready")
async def readiness_check():
    """Readiness check - verifies agent is fully initialized."""
    if adapter is None or spec is None:
        raise HTTPException(status_code=503, detail="Agent not ready")
    return {"status": "ready", "agent": AGENT_NAME}


@app.get("/schema")
async def get_schema():
    """Get the input/output schema for this agent."""
    return {
        "agent": AGENT_NAME,
        "input_schema": {{ io_schema.input | tojson if io_schema and io_schema.input else '{}' }},
        "output_schema": {{ io_schema.output | tojson if io_schema and io_schema.output else '{}' }}
    }


@app.get("/info")
async def get_info():
    """Get agent metadata and configuration."""
    return {
        "agent": {
            "name": AGENT_NAME,
            "description": AGENT_DESCRIPTION,
            "framework": AGENT_FRAMEWORK,
            "entrypoint": AGENT_ENTRYPOINT
        },
        {%- if model %}
        "model": {
            "provider": MODEL_PROVIDER,
            "name": MODEL_NAME,
            "temperature": MODEL_TEMPERATURE,
            "max_tokens": MODEL_MAX_TOKENS
        },
        {%- endif %}
        {%- if metadata %}
        "metadata": {{ metadata | tojson }},
        {%- endif %}
        "auth_enabled": AUTH_ENABLED
    }


@app.get("/metrics")
async def prometheus_metrics():
    """Prometheus metrics endpoint."""
    data = generate_latest()
    return Response(content=data, media_type=CONTENT_TYPE_LATEST)


@app.post("/invoke")
async def invoke_agent(
    request: Request,
    api_key: Optional[str] = Depends(verify_api_key)
):
    """
    Invoke the agent with the given payload.
    
    The adapter layer handles framework-specific invocation logic,
    providing a unified interface regardless of underlying framework.
    """
    ACTIVE_REQUESTS.labels(agent=AGENT_NAME).inc()
    start_time = time.time()
    
    try:
        # Parse request payload
        try:
            payload = await request.json()
        except json.JSONDecodeError:
            raise ValidationError("Invalid JSON payload")
        
        logger.info(f"ðŸ“¥ Invoke request received", extra={"payload_keys": list(payload.keys())})
        
        # Validate input schema
        validate_input_schema(payload)
        
        # Apply input policies
        payload = policy_engine.validate_input(payload)
        
        # Invoke agent via adapter
        logger.debug(f"Invoking {AGENT_FRAMEWORK} agent...")
        
        {%- if arguments and arguments.timeout_sec %}
        # Apply timeout
        try:
            result = await asyncio.wait_for(
                asyncio.get_event_loop().run_in_executor(
                    None, lambda: adapter.invoke(payload)
                ),
                timeout=TIMEOUT_SEC
            )
        except asyncio.TimeoutError:
            raise DockrionError(f"Agent invocation timed out after {TIMEOUT_SEC}s")
        {%- else %}
        result = adapter.invoke(payload)
        {%- endif %}
        
        # Apply output policies
        result = policy_engine.apply_output_policies(result)
        
        latency = time.time() - start_time
        
        # Record metrics
        REQUEST_COUNT.labels(agent=AGENT_NAME, endpoint="invoke", status="success").inc()
        REQUEST_LATENCY.labels(agent=AGENT_NAME, endpoint="invoke").observe(latency)
        
        logger.info(f"âœ… Invoke completed in {latency:.3f}s")
        
        return JSONResponse({
            "success": True,
            "output": result,
            "metadata": {
                "agent": AGENT_NAME,
                "framework": AGENT_FRAMEWORK,
                "latency_seconds": round(latency, 3)
            }
        })
        
    except ValidationError as e:
        latency = time.time() - start_time
        REQUEST_COUNT.labels(agent=AGENT_NAME, endpoint="invoke", status="validation_error").inc()
        logger.warning(f"âš ï¸ Validation error: {e}")
        
        return JSONResponse(
            status_code=400,
            content={
                "success": False,
                "error": str(e),
                "error_type": "ValidationError"
            }
        )
        
    except DockrionError as e:
        latency = time.time() - start_time
        REQUEST_COUNT.labels(agent=AGENT_NAME, endpoint="invoke", status="dockrion_error").inc()
        logger.error(f"âŒ Dockrion error: {e}")
        
        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "error": str(e),
                "error_type": "DockrionError"
            }
        )
        
    except Exception as e:
        latency = time.time() - start_time
        REQUEST_COUNT.labels(agent=AGENT_NAME, endpoint="invoke", status="error").inc()
        logger.error(f"âŒ Unexpected error: {e}", exc_info=True)
        
        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "error": str(e),
                "error_type": type(e).__name__
            }
        )
        
    finally:
        ACTIVE_REQUESTS.labels(agent=AGENT_NAME).dec()


{%- if expose and expose.streaming %}

@app.post("/invoke/stream")
async def invoke_agent_stream(
    request: Request,
    api_key: Optional[str] = Depends(verify_api_key)
):
    """
    Invoke the agent with streaming response (SSE).
    
    Streams partial results as they become available.
    """
    ACTIVE_REQUESTS.labels(agent=AGENT_NAME).inc()
    
    try:
        payload = await request.json()
        
        # Validate
        validate_input_schema(payload)
        payload = policy_engine.validate_input(payload)
        
        async def event_generator() -> AsyncGenerator[str, None]:
            try:
                # Check if adapter supports streaming
                if hasattr(adapter, 'invoke_stream'):
                    async for chunk in adapter.invoke_stream(payload):
                        yield f"data: {json.dumps({'chunk': chunk})}\n\n"
                else:
                    # Fallback to single response
                    result = adapter.invoke(payload)
                    yield f"data: {json.dumps({'output': result})}\n\n"
                
                yield f"data: {json.dumps({'done': True})}\n\n"
                
            except Exception as e:
                yield f"data: {json.dumps({'error': str(e)})}\n\n"
            finally:
                ACTIVE_REQUESTS.labels(agent=AGENT_NAME).dec()
        
        return StreamingResponse(
            event_generator(),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
            }
        )
        
    except Exception as e:
        ACTIVE_REQUESTS.labels(agent=AGENT_NAME).dec()
        raise HTTPException(status_code=500, detail=str(e))

{%- endif %}


# ============================================================================
# Main Entry Point
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    
    logger.info(f"Starting {AGENT_NAME} on {HOST}:{PORT}")
    uvicorn.run(
        app,
        host=HOST,
        port=PORT,
        log_level="info"
    )
